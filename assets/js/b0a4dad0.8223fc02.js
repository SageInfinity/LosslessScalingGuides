"use strict";(self.webpackChunkls_guide=self.webpackChunkls_guide||[]).push([[727],{8453:(e,s,a)=>{a.d(s,{R:()=>r,x:()=>o});var n=a(6540);const i={},t=n.createContext(i);function r(e){const s=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(t.Provider,{value:s},e.children)}},8611:(e,s,a)=>{a.d(s,{A:()=>n});const n=a.p+"assets/images/Scalers-e0c95b7b5371cb1be1ad207c8a12b4ae.png"},8678:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"FAQ/scalers","title":"What are Spatial Scalers in LS?","description":"Information about Spatial Scalers in LS","source":"@site/docs/FAQ/1. Spatial Scalers in LS.md","sourceDirName":"FAQ","slug":"/FAQ/scalers","permalink":"/docs/FAQ/scalers","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"What are Spatial Scalers in LS?","description":"Information about Spatial Scalers in LS","id":"scalers"},"sidebar":"docs","next":{"title":"What is Flow Scale?","permalink":"/docs/FAQ/flowscale"}}');var i=a(4848),t=a(8453);const r={title:"What are Spatial Scalers in LS?",description:"Information about Spatial Scalers in LS",id:"scalers"},o=void 0,l={},c=[{value:"How to use Scalers in LS?",id:"how-to-use-scalers-in-ls",level:2},{value:"What is the General Usage and Priority for Scalers?",id:"what-is-the-general-usage-and-priority-for-scalers",level:2},{value:"Use case &amp; tendency of Scalers?",id:"use-case--tendency-of-scalers",level:2},{value:"LS1",id:"ls1",level:3},{value:"SGSR1",id:"sgsr1",level:3},{value:"BCAS",id:"bcas",level:3},{value:"FSR",id:"fsr",level:3},{value:"NIS",id:"nis",level:3},{value:"xBR",id:"xbr",level:3},{value:"Anime4k",id:"anime4k",level:3}];function d(e){const s={h2:"h2",h3:"h3",img:"img",p:"p",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"alt-text",src:a(8611).A+"",width:"446",height:"481"})}),"\n",(0,i.jsx)(s.h2,{id:"how-to-use-scalers-in-ls",children:"How to use Scalers in LS?"}),"\n",(0,i.jsx)(s.p,{children:"The scalers present in LS require Borderless Fullscreen and Windowed Mode to work. To upscale games in Borderless Fullscreen, the Scaling Mode needs to be set to Custom with Resize before scaling enabled. This requires the use of a manual scaling factor where at 4k for example: a factor of 1.2/1.5/2.0 would result in an upscale of 1800p/1440p/1080p to 4k respectively. The Status Tab at the very bottom also displays the resized -> output resolution"}),"\n",(0,i.jsx)(s.p,{children:"Some games may not work with resize before scaling as the game may not like window manipulation when borderless. This is rare, but can be overcome by setting the game to Windowed mode and scaling based off the said window. The Scaling mode needs to be changed to Auto where LS will automatically fill the screen with the correct scaling factor to upscale to native resolution"}),"\n",(0,i.jsx)(s.p,{children:'Scaling without FG/LSFG is currently known to cause unstable frame capture or dropped frames with both WGC/DXGI. A temporary workaround is to either disable Variable Refresh Rate or use FG when using the spatial scalers. This is due to a bug with WDDM from Microsoft which is currently under investigation."'}),"\n",(0,i.jsx)(s.h2,{id:"what-is-the-general-usage-and-priority-for-scalers",children:"What is the General Usage and Priority for Scalers?"}),"\n",(0,i.jsx)(s.p,{children:"LS1 > SGSR/BCAS > FSR > NIS > xBR"}),"\n",(0,i.jsx)(s.p,{children:"The general order above represents how good each of the  scalers are likely to look in any given 3D/2D game. The final image quality of the scaler vary depending on the game and content. All the upscalers in LS work best with ingame Anti-Aliasing (TAA, FXAA, MSAA) enabled. These upscalers are not Anti-Aliasing replacements like SMAA/CMAA2/FXAA"}),"\n",(0,i.jsx)(s.p,{children:"The scalers within LS can also be used at native resolution alongside in-game TAA upscalers that do the actual upscaling i.e: DLSS/FSR2/XeSS. This can help with soft/poor in-game TAA implementations, where the LS scaler can improve edge resolve"}),"\n",(0,i.jsx)(s.p,{children:"The compute cost for each upscaler can vary between gpu vendors, therefore there is no universal \u201clightest spatial scaler\u201d. In general SGSR & BicubicCAS should be the lightest in most systems. FSR1.1 and LS1, with their performance toggles are similar in cost, with LS1 being slightly heavier. The non-performance LS1 upscaler is the heaviest and should be used only when performance is not the primary concern, as it generally looks very similar to LS1 with its Performance toggle enabled."}),"\n",(0,i.jsx)(s.h2,{id:"use-case--tendency-of-scalers",children:"Use case & tendency of Scalers?"}),"\n",(0,i.jsx)(s.h3,{id:"ls1",children:"LS1"}),"\n",(0,i.jsx)(s.p,{children:"Use case: Lossless Scaling's own machine learning based upscaler, recommended for use in games/videos with good motion handling. Sharpness values of 0 and 1 preferred to minimise aliasing. The performance toggle significantly reduces its compute cost whilst maintaining similar quality"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: Can effectively reduce both occlusion artifacts and motion smearing. Sharpness values of 2-4 can lead to haloing and dithering in motion. Generally performs the best and is well-suited for games with complex 3D scenes, foliage, particles, and reflections"}),"\n",(0,i.jsx)(s.h3,{id:"sgsr1",children:"SGSR1"}),"\n",(0,i.jsx)(s.p,{children:"Use case: A spatial upscaler by Qualcomm that is light and provides good image quality. Often a superior alternative to Bicubic CAS with a sharper output at a low compute cost. Looks good with 2d pixel art and 3d games and avoids ringing artifacts"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: Uses a 12-tap Lanczos-like scaling filter and adaptive sharpening. Has minimal dithering and avoids oversharpening most scenes. Can struggle with colour banding and blending gradients such as sky/shadows when upscaling from very low internal resolutions"}),"\n",(0,i.jsx)(s.h3,{id:"bcas",children:"BCAS"}),"\n",(0,i.jsx)(s.p,{children:"Use case: Combines Bicubic upscaling with Contrast adaptive sharpening, with a similar final look to SGSR. Well suited for pixel art and softer art styles, with very low performance overhead. Can look good with both 2d and 3d content"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: Can have difficulty with texture blending & gradient handling. Games with emphasis on particles, alpha effects and reflections may look soft and less-defined in motion. SGSR may be preferred over BCAS in these circumstances"}),"\n",(0,i.jsx)(s.h3,{id:"fsr",children:"FSR"}),"\n",(0,i.jsx)(s.p,{children:"Use case: AMDs spatial upscaler, with both a regular and optimised kernel in Lossless Scaling. FSR1.1 works well with most content and has low compute overhead. Sharpness values of 3-5 look best and will generally not oversharpen games"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: Can mush and blend high frequency detail leading to loss of clarity in high contrast areas. FSR can often look more pixelated and smeary in fast motion; generally around bright foliage. Can avoid dithering in most scenes but has swirling artifacts with alpha effects & shadows from low resolutions"}),"\n",(0,i.jsx)(s.h3,{id:"nis",children:"NIS"}),"\n",(0,i.jsx)(s.p,{children:"Use case: Spatial upscaler from Nvidia that is generally not preferred for either 3d/2d content due to its aggressive use of sharpening. Can be used if one prefers a sharper look or used on a very blurry game"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: Has general issue with edge contrast, leading to haloing around objects with a dithered look in motion. Very often causes ringing artifacts and over sharpens both textures and geometry. Generally not preferred and should be avoided"}),"\n",(0,i.jsx)(s.h3,{id:"xbr",children:"xBR"}),"\n",(0,i.jsx)(s.p,{children:"Use case: xBR is a semi-popular pixel art/retro game upscaler. It performs diagonal smoothing very aggressively to remove jagged lines. Typically used to upscale 3rd to 5th generation of console games"}),"\n",(0,i.jsx)(s.p,{children:"Tendency: A mostly artistic shader with an oil painting resolve. Makes pixel art content blurry with aggressive smoothing that lead to loss of detail. Generally ruins the intended look of older games and looks unnatural"}),"\n",(0,i.jsx)(s.h3,{id:"anime4k",children:"Anime4k"}),"\n",(0,i.jsx)(s.p,{children:"Use Case: Strictly intended to be used on 1080p sources, which it upscales to 4k. Does not work well and has issues with low bitrate/resolution video sources such as 720p"}),"\n",(0,i.jsx)(s.p,{children:'Tendency: Can be very computationally heavy when using the Very Large/Ultra Large models. LS uses the stock Anime4K shader and does no additional sharpness pass unlike the Magpie version. LS1 can often look similar/better at a cheaper compute cost"'})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);